
# AST Framework

AST-Framework is a versatile C++ framework designed to simplify game development. It provides essential features such as scene management, input handling, rendering, and rectangle manipulation. Additionally, it offers sprite management and supports the integration of physics simulations. The framework is easy to use and customizable, making it suitable for creating a wide range of games. With AST-Framework, developers can focus on creating engaging gameplay experiences without getting bogged down in low-level implementation details.
## Installation

To use the AST-Framework in your project, follow these steps:

1. Clone the repository to your local machine:

   ```bash
   git clone https://github.com/your-username/your-repo.git
   ```

2. Copy the `AST.h` and `AST.cpp` files from the AST-Framework repository and include them in your `main.cpp` file.

3. Create a folder named "Resources" in the root directory of your project. Inside the "Resources" folder, create a subfolder named "GFX". This is where you should store your graphical assets (textures, sprites, etc.).

4. (Optional) Create a folder named "Scenes" in the root directory of your project. This step is recommended but not necessary. Inside the "Scenes" folder, create a file named "Scenes.h". In this file, you can define your scenes using the provided framework.

5. Create individual scene files such as "Scene_Example.cpp" inside the "Scenes" folder for each scene you want to create. Make sure to include the "Scenes.h" file at the top of each scene file and provide definitions for any class members or classes that are defined in "Scenes.h". Refer to the "Examples" section in this README for sample code and usage examples.

6. Configure your build system to include the AST-Framework files (`AST.h` and `AST.cpp`) and any additional dependencies during the compilation process. Refer to the documentation of your build system for instructions on how to include source files and external dependencies.

7. You're ready to start using the AST-Framework in your project! Implement your own scenes and utilize the framework's features based on the examples and documentation provided.

Remember to place your graphical assets in the "Resources/GFX" folder.

If you encounter any issues or have questions, submit it in [issuses tab](https://github.com/mastercuber55/AST-Framework/issues) and the associated documentation for support.
## Note

By default, the AST-Framework does not include the Physics Engine and SDL_image library. However, you can enable these features by following these steps:

- To enable the Physics Engine, you need to pass the compiler flag `-DAST_PHYSICS` during the build process. This will enable the physics-related functionalities provided by the framework.

- If you want to use SDL_image for loading and rendering images, you need to pass the compiler flag `-DAST_TEXTURE` during the build process. This will enable the integration with SDL_image and allow you to load and use various image formats in your project.

Make sure to include the necessary libraries and dependencies in your build configuration when enabling these features. Refer to the documentation of your build system for instructions on how to include the required libraries and flags.

If you don't require the Physics Engine or SDL_image in your project, you can omit these flags during the build process, and the framework will work without them.

Feel free to enable or disable these features based on your project's requirements.

**The documentation is generated by chatGPT and maybe incorrect, open a issue If you find something wrong with it.**

**The Physics Engine is taken from [SKR Framework](https://github.com/SUKRUCIRIS/SKR) and modified so go there for documentation**
##  Documentation

### Namespace: AST

The AST framework is encapsulated within the `AST` namespace. The following variables, classes, and functions are available within this namespace:

#### Variables:

- `win`: A pointer to the SDL window used by the framework.
- `ren`: A pointer to the SDL renderer used by the framework.
- `Mouse`: An auto-updating `SDL_Point` that stores the current position of the mouse.
- `grid`: The size of the grid used for updating the mouse position.
- `FPS`: The desired frames per second for the game loop.
- `loop`: A boolean flag that controls the main game loop.
- `isFullscreen`: A boolean flag indicating whether the game window is in fullscreen mode.
- `keys`: An auto-updated unordered map that can be used as follows `if(AST::keys[SDL_QUIT] || AST::keys[SDL_BUTTON_MIDDLE] || AST::keys[SDLK_Escape]) AST::loop = false;` 
- `code`: An integer variable for custom code or status within your game.

- `world`: A pointer to the `SKR_RectWorld` object representing the physics world. (Available only if AST_PHYSICS flag is defined.)

#### Classes:

- `Scene`: A class representing a game scene.
  - `Scene()`: Constructor for the `Scene` class.
  - `loop()`: Placeholder function for the game loop logic in the `Scene` class.
  - `event(SDL_Event& event)`: Handles SDL events in the `Scene` class.
  - `~Scene()`: Destructor for the `Scene` class.

- `Rect`: A class representing a rectangle.
- `Rect(SDL_FRect rect, SDL_Color color)`: Constructor for creating rectangles without textures.
  - `Rect(SDL_FRect rect, std::string texture)`: Constructor for creating rectangles with textures. (Available only if AST_TEXTURE flag is defined.)
  - `Rect(SDL_FRect rect, SDL_Color start, SDL_Color end)`: Constructor for creating rectangles with gradient color fills.
  - `Init(SDL_FRect rect)`: Initializes the position and size of a `Rect` object.
  - `Physics(float mass, float friction, float gravity)`: Sets up physics properties for a rectangle object. (Available only if AST_PHYSICS flag is defined.)
  - `~Rect()`: Destructor for the `Rect` class.

#### Functions:

- `Init(std::string title, SDL_Rect rect)`: Initializes the AST framework with a window title and initial window dimensions.
#ifdef AST_PHYSICS
- `Init(std::string title, SDL_Rect rect, float WorldGravity, float WorldAirFrictionCoefficient, SKR_GAMETYPE WorldGameType)`: Overloaded version of `Init()` with additional physics settings.
#endif
**Note: Providing -1 as w and h of the rect will cause the window to be maximized.**
- `Render(Scene& scene)`: Starts the main game loop, handles event polling, rendering, and frame rate control.
- `Quit()`: Cleans up and shuts down the AST framework.
- `inRange(int num, int min, int max)`: Checks if a number is within a specified range.
- `hovering(SDL_FRect rect)`: Checks if the mouse cursor is hovering over a rectangle.
- `fullscreen(bool yes)`: Switches the game window between fullscreen and windowed mode.
- `setTimeout(std::function<void()> function, int ms)`: Sets a timeout for executing a function after a specified delay.

**Note:** 
- The `setTimeout` function is non-blocking, meaning it will

 not pause the execution of the game loop while waiting for the timeout to elapse.
- The `fullscreen` function can be used as `AST::fullscreen(!AST::isFullscreen)` to toggle the fullscreen mode.
- The `hovering` function can be used in combination with `AST::keys["LMB"]` within an `if` statement to check if a rectangle is clicked.
- The `Physics` function in the `Rect` class is only available if the `AST_PHYSICS` flag is defined during compilation.
- The `Rect` constructor that accepts a texture parameter is only available if the `AST_TEXTURE` flag is defined during compilation.
- The `loop` variable is automatically set to `true` when a scene is initialized, indicating that the game loop should continue running.
- Setting `loop` to `false` within a scene will stop the execution of that scene's game loop, but it won't terminate the entire program.
- The `isFullscreen` variable should not be modified directly, as its state is handled by the `fullscreen` function.

For more detailed usage examples, please refer to the Examples section in the documentation.

### Namespace: SpriteManager

The `SpriteManager` namespace provides functionality for managing sprites and rendering rectangles with different fill styles. The following variables, classes, and functions are available within this namespace:

#### Variables:

- `sprites`: A vector of pairs storing loaded SDL textures and corresponding keywords.

#### Functions:

- `load(std::string keyword, std::string file)`: Loads a texture from the specified file path and associates it with the given keyword. Returns `true` if the texture is loaded successfully or already exists, and `false` otherwise.
- `load(std::string keyword, std::string sheetFile, SDL_Rect spriteRect)`: Loads a texture from the specified sprite sheet file path and extracts a sub-rectangle defined by `spriteRect`. The extracted sprite is associated with the given keyword. Returns `true` if the texture is loaded successfully or already exists, and `false` otherwise.
- `drawTRect(AST::Rect rect)`: Renders a textured rectangle represented by the `rect` object. If the corresponding texture is found in the `sprites` vector, it is rendered using `SDL_RenderCopyF` (or `SDL_RenderCopyExF` if `AST_PHYSICS` is defined).
- `free()`: Frees all the loaded textures in the `sprites` vector.

- `drawCRect(AST::Rect rect)`: Renders a rectangle with a solid color fill represented by the `rect` object using `SDL_RenderFillRectF`.
- `drawGRect(AST::Rect rect)`: Renders a rectangle with a gradient color fill represented by the `rect` object using `SDL_RenderDrawLine`.
- `draw(AST::Rect rect)`: Renders a rectangle based on its type, either as a textured rectangle (if `AST_TEXTURE` is defined), a solid color-filled rectangle, or a gradient color-filled rectangle.

**Note:**
- The `load` functions are responsible for loading and caching textures, preventing redundant loading of the same texture.
- The `drawTRect` function checks if the corresponding texture is loaded and renders it if found, using different rendering functions depending on whether `AST_PHYSICS` is defined.
- The `drawCRect` function fills a rectangle with a solid color using `SDL_RenderFillRectF`.
- The `drawGRect` function draws a rectangle with a gradient color fill by calculating color steps and drawing horizontal lines for each row of the rectangle.
- The `draw` function selects the appropriate rendering function based on the type of the `rect` object, either rendering a textured rectangle (if `AST_TEXTURE` is defined), a solid color-filled rectangle, or a gradient color-filled rectangle.
- The `free` function frees all the loaded textures in the `sprites` vector.



## Usage/Examples
**main.cpp**
```cpp
#include "AST.h" //or #include <AST.h>

int main(int argc, char *argv[]) {
	AST::Init("WINDOW TITLE HERE", {0, 0, -1, -1});
	AST::World = SKR_CreateRectWorld(9.8, 0.0, SKR_SIDESCROLLER);

	{
		Scene_Name NameScene;
		AST::Render(NameScene);
	}

	if(AST::code == 42) {
		Scene_Name NameScene;
		AST::Render(NameScene);
	}

	AST::Quit();
	return false;
}
```
**Scenes/Scenes.h**
```cpp
#pragma once

#include "../AST.h"// or #include <AST.h>

class Scene_Name : public AST::Scene {
	AST::Rect Background;
	public:
		Scene_Name();
		void loop() override;
		void event(SDL_Event &ev) override;
		~Scene_Name();
};
```

**Scenes/Scene_Name.cpp**
```cpp
#include "Scenes.h" 
 
Scene_Name::Scene_Name() : Background(0, 0, -1, -1, "SomeKeyword") { 
    SpriteManager::load("SomeKeyword", "AnyImageStoredInGFXfolderWhichIsInsideResourcesFolder.png"); 
    SpriteManager::load("SomeKeyword2", "AnySpriteSheetStoredInGFXfolderWhichIsInsideResourcesFolder.png", {64, 64, 32, 32}); 
    AST::code = 42;
} 
 
void Scene_Name::loop() { 
 	SpriteManager::draw(Background);
} 

void Scene_Name::event(SDL_Event &ev) { 
    if(AST::keys[SDL_QUIT]) AST::loop = false; 
} 

Scene_Name::~Scene_Name() { 
    SpriteManager::free(); 
}
```

## Acknowledgements

[SKR Framework](https://github.com/SUKRUCIRIS/SKR)